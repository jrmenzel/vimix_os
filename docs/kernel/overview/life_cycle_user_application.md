# Life Cycle of a User Application

## The First Process

Process 0 gets initialized in [init_userspace](../processes/init_userspace.md).

## New Processes

Normal processes start with [fork](../syscalls/fork.md):

- fork creates a new process
  - new processes have set their return address (`context.ra`) to `forkret()`
- `forkret()` will return to user space
  - this happens via `return_to_user_mode()` and `return_to_user_mode_asm` (`u_mode_trap_vector.S`)

## New Applications

New programs start in an existing process via [execv](../syscalls/execv.md):

- [execv](../syscalls/execv.md) reads an ELF file from disk, copies the binary code into memory, sets the arguments and sets the program counter of the user mode context to the application start in memory
- Return from the syscall will return to the new code at the application start.
  - The first code for all applications is `_start` from `crt0.c`, the standard library for all apps.
    - It sets the stdin / stdout and stderr files to 0,1 and 2. For all applications these will be already setup as `init` did this and is the parent of all other processes (see [init_userspace](../processes/init_userspace.md), [stdio](../../misc/stdio.md)).
  - Then `main()` gets called and the return value provided to [exit](../syscalls/exit.md) (this way it also ensures that [exit](../syscalls/exit.md) gets called as `_start` can not return to anywhere.)

## Syscalls

When a [syscalls](../syscalls/syscalls.md) is called, a function generated by `usys.pl` will call `ecall` to trigger a software interrupt (see also [calling_syscall](../syscalls/calling_syscall.md)).

- Calls `u_mode_trap_vector`  (`u_mode_trap_vector.S`) which stores the context and sets the per process kernel stack and kernel page table
- Calls `user_mode_interrupt_handler()`
- Calls `handle_syscall()`, `syscall()` and finally the matching system call (`sys_*`).
- On return of the interrupt handler, `return_to_user_mode()` switches the contexts back and jumps to user mode.

### Sleeping

A syscall can trigger a `sleep()`.
`sleep()` sets the processes state to `TASK_SLEEPING`, set the processes `chan` value to any pointer value and calls `scheduler()`.
Another process must call `wakeup()` with the same pointer value to wake up all processes with that `chan` value (set to `TASK_RUNNABLE` and let the next [scheduling](../processes/scheduling.md) run start them).

### Timer Interrupts

A [timer_interrupt](../interrupts/timer_interrupt.md) stops the program and calls the [scheduler](../processes/scheduling.md).

## exit()

When [exit](../syscalls/exit.md) is called (automatically if `main()` returns), all resources of the process get freed and the processes children gets re-parented to be a child of process 0.

The entry in the process table does not get freed until the parent of the dead process calls `wait()`. For processes with parent being process 0, the init program will call `wait()` in a loop to cleanup exiting lost child processes.

**Note:** Process 0 is not allowed to return, see [init_userspace](../processes/init_userspace.md).

## kill()

When [kill](../syscalls/kill.md) is called with signal `SIGKILL`, the killed flag is set to true and the process is woken up in case it sleeps.

At this point the process could still be running on another CPU. Any [syscalls](../syscalls/syscalls.md) will now result in `exit(-1)`. The same will happen in the next timer interrupt.

## Unhandled Interrupts

Unhandled interrupts (user mode and kernel mode) will set the process flag to killed (effectively calling `kill()`).

---
**Overview:** [kernel](../kernel.md)

**Boot:** [boot_process](boot_process.md) | [init_overview](init_overview.md)

**See also:** [life_cycle_cpu](life_cycle_cpu.md) [life_cycle_user_application](life_cycle_user_application.md)
